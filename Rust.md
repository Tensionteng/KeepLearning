# PartialOrd 和 Ord

翻译过来就是部分等和全等的关系。在Rust中，float类型只实现了`PartialOrd`这个trait，没有实现`Ord`这个trait。原因在于，float类型中有一个`NaN`的值不能用来比较，`NaN`和任何数比较都是`NaN`。

`PartialOrd`是`Ord`的子集，这部分内容也可以用离散数学里面的偏序和全序来理解。

[参考资料](https://rustcc.cn/article?id=6b1d9149-b557-45ea-81f2-8bd4fd9c8e6f)


# 异步编程模型
[参考资料](https://course.rs/advance/async/getting-started.html)
## OS线程模型
> Rust语言的多线程模型是 1:1 OS线程的的

OS 线程非常适合少量任务并发，因为线程的创建和上下文切换是非常昂贵的，甚至于空闲的线程都会消耗系统资源。虽说线程池可以有效的降低性能损耗，但是也无法彻底解决问题。

当然，线程模型也有其优点，例如它不会破坏你的代码逻辑和编程模型，你之前的顺序代码，经过少量修改适配后依然可以在新线程中直接运行，同时在某些操作系统中，你还可以改变线程的优先级，这对于实现驱动程序或延迟敏感的应用(例如硬实时系统)很有帮助。

对于长时间运行的 CPU 密集型任务，例如并行计算，使用线程将更有优势。 这种密集任务往往会让所在的线程持续运行，任何不必要的线程切换都会带来性能损耗，因此高并发反而在此时成为了一种多余。同时你所创建的线程数应该等于 CPU 核心数，充分利用 CPU 的并行能力，甚至还可以将线程绑定到 CPU 核心上，进一步减少线程上下文切换。
## async模型
高并发更适合 IO 密集型任务，例如 web 服务器、数据库连接等等网络服务，因为这些任务绝大部分时间都处于等待状态，如果使用多线程，那线程大量时间会处于无所事事的状态，再加上线程上下文切换的高昂代价，让多线程做 IO 密集任务变成了一件非常奢侈的事。而使用async，既可以有效的降低 CPU 和内存的负担，又可以让大量的任务并发的运行，一个任务一旦处于IO或者其他等待(阻塞)状态，就会被立刻切走并执行另一个任务，而这里的任务切换的性能开销要远远低于使用多线程时的线程上下文切换。

事实上, async 底层也是基于线程实现，但是它基于线程封装了一个运行时，可以将多个任务映射到少量线程上，然后将线程切换变成了任务切换，后者仅仅是内存中的访问，因此要高效的多。

不过async也有其缺点，原因是编译器会为async函数生成状态机，然后将整个运行时打包进来，这会造成我们编译出的二进制可执行文件体积显著增大。

## 如何选择异步编程模型
- 有大量 IO 任务需要并发运行时，选 async 模型
- 有部分 IO 任务需要并发运行时，选多线程，如果想要降低线程创建和销毁的开销，可以使用线程池
- 有大量 CPU 密集任务需要并行运行时，例如并行计算，选多线程模型，且让线程数等于或者稍大于 CPU 核心数
- 无所谓时，统一选多线程

# 生命周期
一言以蔽之，被引用的数据的生命周期**必须大于**引用本身的生命周期。

## 函数与生命周期
若一个参数返回了引用类型，那么它的生命周期只可能来源于：

- 传入参数的生命周期
- 函数中某个新建引用的生命周期(极易引起悬垂引用)

## 结构体与生命周期
为结构体中每个引用显式地标注生命周期
```
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```
该生命周期标注说明，结构体 `ImportantExcerpt` 所引用的字符串 `str` 必须比该结构体活得更久。

# Rust宏元标签
[参考资料](https://zjp-cn.github.io/tlborm/decl-macros/minutiae/fragment-specifiers.html)
- item: 程序项
- block: 块表达式
- stmt: 语句，注意此选择器不匹配句尾的分号（如果匹配器中提供了分号，会被当做分隔符），但碰到分号是自身的一部分的程序项语句的情况又会匹配。
- pat: 模式
- expr: 表达式
- ty: 类型
- ident: 标识符或关键字
- path: 类型表达式 形式的路径
- tt: token树 (单个 token 或宏匹配定界符 ()、[] 或{} 中的标记)
- meta: 属性，属性中的内容
- lifetime: 生存期token
- vis: 可能为空的可见性限定符
- literal: 匹配 -?字面量表达式